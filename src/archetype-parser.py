import logging
from datetime import datetime, timedelta
from decimal import Decimal
from lark import Lark, logger, Tree, Token
from transformer import ToPythonSource

logger.setLevel(logging.DEBUG)

# V2 started on 2021-11-24 to use a transformer and produce Python code
# ended on 2021-11-27
# One can imagine a V3 to generate REST APIs based on the code generated by V2
# Lark Grammar Reference: https://lark-parser.readthedocs.io/en/latest/grammar.html
# Lark Cheatsheet: https://lark-parser.readthedocs.io/en/latest/_static/lark_cheatsheet.pdf
# Archetype Reference: https://docs.archetype-lang.org/archetype-reference
# Archetype Examples: https://archetype-lang.org/

lark_ebnf_grammar = '''
start: "archetype" START_NAME "(" parameters* ")" (entry|transition|states)+

START_NAME: ("a".."z"|"_")+
NAME: ("a".."z"|"_")+
parameters: PARAMETER_NAME ":" PARAMETER_TYPE
PARAMETER_NAME: ("a".."z"|"_")+
PARAMETER_TYPE: ("a".."z"|"_")+

entry: "entry" ENTRY_NAME "(" parameters* ")" _entry_code_block
transition: "transition" TRANSITION_NAME "()" _transition_code_block
states: "states" "=" ("|" STATE)+

ENTRY_NAME: ("a".."z"|"_")+
TRANSITION_NAME: ("a".."z"|"_")+
STATE: ("a".."z"|"A".."Z")+

_entry_code_block: "{" (transfer|called_by|require|effect)+ "}"
transfer: "transfer" "(" _simple_expr ")" "to holder"
called_by: "called by" USER_NAME
require: "require" "{" rule+ "}"
rule: REQUIRE_NAME ":" (_literal|NAME) COMPARATOR (_literal|NAME) ";"

_transition_code_block: "{" (from|when|effect)+ "}"
from: "from" STATE "to" STATE -> from_
when: "when {" NAME COMPARATOR NUMBER "}"
effect: "effect" "{" (transfer|assignment)+ "}"

assignment: EFFECT_TARGET ":=" EFFECT_VALUE ";"

NUMBER: ("0".."9")+
COMPARATOR: ("<"|">"|"="|"<>"|"<="|">=")
REQUIRE_NAME: ("a".."z"|"_"|"0".."9")+
EFFECT_TARGET: ("a".."z"|"_"|"0".."9")+
EFFECT_VALUE: ("a".."z"|"_"|"0".."9")+
USER_NAME: ("a".."z"|"_"|"0".."9")+

_simple_expr: _simple_expr _LBRACKET _simple_expr _RBRACKET
        | _LBRACKET _RBRACKET
        | _LBRACKET _simple_expr _RBRACKET
        | sum
        | product
        | minus
        | NOW
        | _literal

sum: _simple_expr "+" _simple_expr
product: _simple_expr "*" _simple_expr
minus: _simple_expr " - " _simple_expr

_literal: NUMBER
    | DURATION
    | DATE
    | PERCENT_LIT

_LBRACKET: "("
_RBRACKET: ")"
DURATION: ("0".."9"+"w"("0".."9"+"d")?("0".."9"+"h")?("0".."9"+"m")?("0".."9"+"s")?)|("0".."9"+"d"("0".."9"+"h")?("0".."9"+"m")?("0".."9"+"s")?)|("0".."9"+"h"("0".."9"+"m")?("0".."9"+"s")?)|("0".."9"+"m"("0".."9"+"s")?)|"0".."9"+"s"
DATE: "0".."9"~4"-""0".."9"~2"-""0".."9"~2
PERCENT_LIT: "0".."9"+"%"
NOW: "now"

%import common.WS
%ignore WS
'''

parser = Lark(lark_ebnf_grammar)

smart_contract_1 = '''
archetype smart_contract_lark(holder : address)
entry pay () {
  transfer (1 + 7% * (now - 2021-01-01 + 1w1d)) to holder
}
'''

smart_contract_2 = '''
archetype exec_cond_demo(value : nat)

entry setvalue (v : nat) {
  called by admin
  require {
    r1: transferred > value;
    r2: now < 2022-01-01;
  }
  effect {
    value := v;
  }
}
'''

smart_contract_3 = '''
archetype state_machine_demo(holder : address)

states =
| Created
| Initialized
| Terminated

transition initialize () {
  from Created to Initialized
  when { transferred > 10 }
}

transition terminate () {
  from Initialized to Terminated
  effect { transfer (1 + 1) to holder }
}
'''

parse_tree = parser.parse(smart_contract_1)
print(parse_tree.pretty())

print(ToPythonSource().transform(parse_tree))
